/*
 * These Interop-Declarations are based on 
 * the generated code of FFmpeg.AutoGen.
 * 
 * See: https://github.com/Ruslan-B/FFmpeg.AutoGen
 * 
 * The author of FFmpeg.AutoGen gave the explicit
 * permission to modify and publish the 
 * Interop-Declarations (generated by FFmpeg.AutoGen) 
 * within CSCore under the MS-PL.
 * 
 * @Ruslan Balanukhin: Big Thanks!
 */

using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;

namespace CSCore.Ffmpeg
{
    internal static unsafe class InteropCalls
    {
        private static readonly string DllPathWinx86 = Path.Combine(
            Path.GetDirectoryName(Assembly.GetEntryAssembly().Location),
            Path.Combine(Path.Combine("ffmpeg", "3.0.2"), "x86"));

        private static readonly string DllPathWinx64 = Path.Combine(
            Path.GetDirectoryName(Assembly.GetEntryAssembly().Location),
            Path.Combine(Path.Combine("ffmpeg", "3.0.2"), "x64"));

        [DllImport("kernel32", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)]string lpFileName);

        static InteropCalls()
        {
            bool x64 = IntPtr.Size == 8;
            //the order is important!
            string[] librariesToLoad = { 
                LibAvUtil,
                LibSwResample,
                LibAvCodec,
                LibAvFormat
            };

            if (Environment.OSVersion.Platform == PlatformID.Win32Windows ||
                Environment.OSVersion.Platform == PlatformID.Win32NT ||
                Environment.OSVersion.Platform == PlatformID.Win32S ||
                Environment.OSVersion.Platform == PlatformID.WinCE)
            {
                foreach (var libary in librariesToLoad)
                {
                    var path = Path.Combine(x64 ? DllPathWinx64 : DllPathWinx86, Path.ChangeExtension(libary, ".dll"));
                    IntPtr ptr = LoadLibrary(path);
                    if (ptr == IntPtr.Zero)
                    {
                        throw new DllNotFoundException(String.Format("{0} was not found.", libary),
                            new FileNotFoundException("Dll not found.", path));
                    }
                }
            }
        }

        private const string LibAvUtil = "avutil-55";
        private const string LibAvCodec = "avcodec-57";
        private const string LibAvFormat = "avformat-57";
        private const string LibSwResample = "swresample-2";

        public delegate int AvioReadData(IntPtr opaque, IntPtr buffer, int bufferSize);

        public delegate int AvioWriteData(IntPtr opaque, IntPtr buffer, int bufferSize);

        public delegate long AvioSeek(IntPtr opaque, long offset, SeekFlags whence);

        [Flags]
        public enum SeekFlags
        {
            SeekSet = 0,
            SeekCur = 1,
            SeekEnd = 2,
            SeekSize = 0x10000,
            SeekForce = 0x20000
        }

        [DllImport(LibAvUtil, EntryPoint = "av_malloc", CallingConvention = CallingConvention.Cdecl)]
        public static extern void* av_malloc(ulong @size);

        [DllImport(LibAvFormat, EntryPoint = "avio_alloc_context", CallingConvention = CallingConvention.Cdecl)]
        public static extern AVIOContext* avio_alloc_context(byte* @buffer, int @buffer_size, int @write_flag, void* @opaque, 
            [MarshalAs(UnmanagedType.FunctionPtr)]AvioReadData @read_packet,
            [MarshalAs(UnmanagedType.FunctionPtr)]AvioWriteData @write_packet, 
            [MarshalAs(UnmanagedType.FunctionPtr)]AvioSeek @seek);

        [DllImport(LibAvFormat, EntryPoint = "avformat_alloc_context", CallingConvention = CallingConvention.Cdecl)]
        public static extern AVFormatContext* avformat_alloc_context();

        [DllImport(LibAvFormat, EntryPoint = "avformat_free_context", CallingConvention = CallingConvention.Cdecl)]
        public static extern void avformat_free_context(AVFormatContext* @s);

        [DllImport(LibAvFormat, EntryPoint = "avformat_open_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern int avformat_open_input(AVFormatContext** ps, [MarshalAs(UnmanagedType.LPStr)] string url, AVInputFormat* fmt, AVDictionary** options);

        [DllImport(LibAvFormat, EntryPoint = "avformat_find_stream_info", CallingConvention = CallingConvention.Cdecl)]
        public static extern int avformat_find_stream_info(AVFormatContext* ic, AVDictionary** options);

        [DllImport(LibAvFormat, EntryPoint = "av_find_best_stream", CallingConvention = CallingConvention.Cdecl)]
        public static extern int av_find_best_stream(AVFormatContext* ic, AVMediaType type, int wanted_stream_nb, int related_stream, AVCodec** decoder_ret, int flags);

        [DllImport(LibAvUtil, EntryPoint = "av_frame_alloc", CallingConvention = CallingConvention.Cdecl)]
        public static extern AVFrame* av_frame_alloc();

        [DllImport(LibAvCodec, EntryPoint = "avcodec_register_all", CallingConvention = CallingConvention.Cdecl)]
        public static extern void avcodec_register_all();

        [DllImport(LibAvCodec, EntryPoint = "avcodec_find_decoder", CallingConvention = CallingConvention.Cdecl)]
        public static extern AVCodec* avcodec_find_decoder(AVCodecID id);

        [DllImport(LibAvCodec, EntryPoint = "avcodec_open2", CallingConvention = CallingConvention.Cdecl)]
        public static extern int avcodec_open2(AVCodecContext* avctx, AVCodec* codec, AVDictionary** options);

        [DllImport(LibAvCodec, EntryPoint = "av_init_packet", CallingConvention = CallingConvention.Cdecl)]
        public static extern void av_init_packet(AVPacket* pkt);

        [DllImport(LibAvCodec, EntryPoint = "av_free_packet", CallingConvention = CallingConvention.Cdecl)]
        public static extern void av_free_packet(AVPacket* pkt);

        [DllImport(LibAvFormat, EntryPoint = "av_read_frame", CallingConvention = CallingConvention.Cdecl)]
        public static extern int av_read_frame(AVFormatContext* s, AVPacket* pkt);

        [DllImport(LibAvCodec, EntryPoint = "avcodec_decode_audio4", CallingConvention = CallingConvention.Cdecl)]
        public static extern int avcodec_decode_audio4(AVCodecContext* avctx, AVFrame* frame, int* got_frame_ptr, AVPacket* avpkt);

        [DllImport(LibAvCodec, EntryPoint = "avcodec_close", CallingConvention = CallingConvention.Cdecl)]
        public static extern int avcodec_close(AVCodecContext* avctx);

        [DllImport(LibAvFormat, EntryPoint = "avformat_close_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern void avformat_close_input(AVFormatContext** s);

        [DllImport(LibAvUtil, EntryPoint = "av_free", CallingConvention = CallingConvention.Cdecl)]
        public static extern void av_free(void* ptr);

        [DllImport(LibAvFormat, EntryPoint = "av_register_all", CallingConvention = CallingConvention.Cdecl)]
        public static extern void av_register_all();

        [DllImport(LibAvUtil, EntryPoint = "av_dict_set", CallingConvention = CallingConvention.Cdecl)]
        public static extern int av_dict_set(AVDictionary** pm, [MarshalAs(UnmanagedType.LPStr)] string key, [MarshalAs(UnmanagedType.LPStr)] string value, int flags);

        [DllImport(LibAvFormat, EntryPoint = "av_seek_frame", CallingConvention = CallingConvention.Cdecl)]
        public static extern int av_seek_frame(AVFormatContext* s, int stream_index, long timestamp, int flags);

        [DllImport(LibAvUtil, EntryPoint = "av_strerror", CallingConvention = CallingConvention.Cdecl)]
        public static extern int av_strerror(int errnum, IntPtr errbuf, ulong errbuf_size);

        [DllImport(LibAvUtil, EntryPoint = "av_samples_get_buffer_size", CallingConvention = CallingConvention.Cdecl)]
        public static extern int av_samples_get_buffer_size(int* linesize, int nb_channels, int nb_samples, AVSampleFormat sample_fmt, int align);

        [DllImport(LibAvFormat, EntryPoint = "avformat_seek_file", CallingConvention = CallingConvention.Cdecl)]
        public static extern int avformat_seek_file(AVFormatContext* s, int stream_index, long min_ts, long ts, long max_ts, int flags);

        public const int AV_TIME_BASE = 1000000;

        public static int av_get_bytes_per_sample(AVSampleFormat sampleFormat)
        {
            int bits = 0;
            switch (sampleFormat)
            {
                case AVSampleFormat.AV_SAMPLE_FMT_U8:
                case AVSampleFormat.AV_SAMPLE_FMT_U8P:
                    bits = 8;
                    break;
                case AVSampleFormat.AV_SAMPLE_FMT_S16:
                case AVSampleFormat.AV_SAMPLE_FMT_S16P:
                    bits = 16;
                    break;
                case AVSampleFormat.AV_SAMPLE_FMT_S32:
                case AVSampleFormat.AV_SAMPLE_FMT_S32P:
                case AVSampleFormat.AV_SAMPLE_FMT_FLT:
                case AVSampleFormat.AV_SAMPLE_FMT_FLTP:
                    bits = 32;
                    break;
                case AVSampleFormat.AV_SAMPLE_FMT_DBL:
                case AVSampleFormat.AV_SAMPLE_FMT_DBLP:
                    bits = 64;
                    break;
            }

            int samplefmt = (int)sampleFormat;
            return samplefmt < 0 || sampleFormat == AVSampleFormat.AV_SAMPLE_FMT_NB
                ? 0
                : bits >> 3;
        }

        public unsafe partial struct AVPacket
        {
            public AVBufferRef* buf;
            public long pts;
            public long dts;
            public sbyte* data;
            public int size;
            public int stream_index;
            public int flags;
            public IntPtr side_data;
            public int side_data_elems;
            public long duration;
            public long pos;
            public long convergence_duration;
        }

        public unsafe partial struct AVFormatContext
        {
            public IntPtr av_class;
            public AVInputFormat* iformat;
            public AVOutputFormat* oformat;
            public void* priv_data;
            public AVIOContext* pb;
            public int ctx_flags;
            public uint nb_streams;
            public AVStream** streams;
            public fixed sbyte filename[1024];
            public long start_time;
            public long duration;
            public long bit_rate;
            public uint packet_size;
            public int max_delay;
            public int flags;
            public long probesize;
            public long max_analyze_duration;
            public sbyte* key;
            public int keylen;
            public uint nb_programs;
            public IntPtr* programs;
            public AVCodecID video_codec_id;
            public AVCodecID audio_codec_id;
            public AVCodecID subtitle_codec_id;
            public uint max_index_size;
            public uint max_picture_buffer;
            public uint nb_chapters;
            public IntPtr* chapters;
            public AVDictionary* metadata;
            public long start_time_realtime;
            public int fps_probe_size;
            public int error_recognition;
            public AVIOInterruptCB interrupt_callback;
            public int debug;
            public long max_interleave_delta;
            public int strict_std_compliance;
            public int event_flags;
            public int max_ts_probe;
            public int avoid_negative_ts;
            public int ts_id;
            public int audio_preload;
            public int max_chunk_duration;
            public int max_chunk_size;
            public int use_wallclock_as_timestamps;
            public int avio_flags;
            public AVDurationEstimationMethod duration_estimation_method;
            public long skip_initial_bytes;
            public uint correct_ts_overflow;
            public int seek2any;
            public int flush_packets;
            public int probe_score;
            public int format_probesize;
            public sbyte* codec_whitelist;
            public sbyte* format_whitelist;
            public IntPtr @internal;
            public int io_repositioned;
            public AVCodec* video_codec;
            public AVCodec* audio_codec;
            public AVCodec* subtitle_codec;
            public AVCodec* data_codec;
            public int metadata_header_padding;
            public void* opaque;
            public IntPtr control_message_cb;
            public long output_ts_offset;
            public sbyte* dump_separator;
            public AVCodecID data_codec_id;
            public IntPtr open_cb;
            public sbyte* protocol_whitelist;
            public IntPtr io_open;
            public IntPtr io_close;
        }

        public unsafe partial struct AVStream
        {
            public int index;
            public int id;
            public AVCodecContext* codec;
            public void* priv_data;
            public AVFrac pts;
            public AVRational time_base;
            public long start_time;
            public long duration;
            public long nb_frames;
            public int disposition;
            public int discard; //enum
            public AVRational sample_aspect_ratio;
            public AVDictionary* metadata;
            public AVRational avg_frame_rate;
            public AVPacket attached_pic;
            public IntPtr side_data;
            public int nb_side_data;
            public int event_flags;
            public info* info;
            public int pts_wrap_bits;
            public long first_dts;
            public long cur_dts;
            public long last_IP_pts;
            public int last_IP_duration;
            public int probe_packets;
            public int codec_info_nb_frames;
            public AVStreamParseType need_parsing;
            public IntPtr parser; //struct AVCodecParserContext
            public AVPacketList* last_in_packet_buffer;
            public AVProbeData probe_data;
            public fixed long pts_buffer[17];
            public AVIndexEntry* index_entries;
            public int nb_index_entries;
            public uint index_entries_allocated_size;
            public AVRational r_frame_rate;
            public int stream_identifier;
            public long interleaver_chunk_size;
            public long interleaver_chunk_duration;
            public int request_probe;
            public int skip_to_keyframe;
            public int skip_samples;
            public long start_skip_samples;
            public long first_discard_sample;
            public long last_discard_sample;
            public int nb_decoded_frames;
            public long mux_ts_offset;
            public long pts_wrap_reference;
            public int pts_wrap_behavior;
            public int update_initial_durations_done;
            public fixed long pts_reorder_error[17];
            public fixed sbyte pts_reorder_error_count[17];
            public long last_dts_for_order_check;
            public sbyte dts_ordered;
            public sbyte dts_misordered;
            public int inject_global_side_data;
            public sbyte* recommended_encoder_configuration;
            public AVRational display_aspect_ratio;
            public IntPtr priv_pts;
            public IntPtr @internal;
        }

        public unsafe partial struct AVCodecContext
        {
            public IntPtr av_class;
            public int log_level_offset;
            public AVMediaType codec_type;
            public AVCodec* codec;
            public fixed sbyte codec_name[32];
            public AVCodecID codec_id;
            public uint codec_tag;
            public uint stream_codec_tag;
            public void* priv_data;
            public IntPtr @internal;
            public void* opaque;
            public long bit_rate;
            public int bit_rate_tolerance;
            public int global_quality;
            public int compression_level;
            public int flags;
            public int flags2;
            public sbyte* extradata;
            public int extradata_size;
            public AVRational time_base;
            public int ticks_per_frame;
            public int delay;
            public int width;
            public int height;
            public int coded_width;
            public int coded_height;
            public int gop_size;
            public int pix_fmt;
            public int me_method;
            public IntPtr draw_horiz_band;
            public IntPtr get_format;
            public int max_b_frames;
            public float b_quant_factor;
            public int rc_strategy;
            public int b_frame_strategy;
            public float b_quant_offset;
            public int has_b_frames;
            public int mpeg_quant;
            public float i_quant_factor;
            public float i_quant_offset;
            public float lumi_masking;
            public float temporal_cplx_masking;
            public float spatial_cplx_masking;
            public float p_masking;
            public float dark_masking;
            public int slice_count;
            public int prediction_method;
            public int* slice_offset;
            public AVRational sample_aspect_ratio;
            public int me_cmp;
            public int me_sub_cmp;
            public int mb_cmp;
            public int ildct_cmp;
            public int dia_size;
            public int last_predictor_count;
            public int pre_me;
            public int me_pre_cmp;
            public int pre_dia_size;
            public int me_subpel_quality;
            public int dtg_active_format;
            public int me_range;
            public int intra_quant_bias;
            public int inter_quant_bias;
            public int slice_flags;
            public int xvmc_acceleration;
            public int mb_decision;
            public ushort* intra_matrix;
            public ushort* inter_matrix;
            public int scenechange_threshold;
            public int noise_reduction;
            public int me_threshold;
            public int mb_threshold;
            public int intra_dc_precision;
            public int skip_top;
            public int skip_bottom;
            public float border_masking;
            public int mb_lmin;
            public int mb_lmax;
            public int me_penalty_compensation;
            public int bidir_refine;
            public int brd_scale;
            public int keyint_min;
            public int refs;
            public int chromaoffset;
            public int scenechange_factor;
            public int mv0_threshold;
            public int b_sensitivity;
            public int color_primaries; //enum
            public int color_trc; //enum
            public int colorspace; //enum
            public int color_range; //enum
            public int chroma_sample_location; //enum
            public int slices;
            public int field_order; //enum
            public int sample_rate;
            public int channels;
            public AVSampleFormat sample_fmt;
            public int frame_size;
            public int frame_number;
            public int block_align;
            public int cutoff;
            public ulong channel_layout;
            public ulong request_channel_layout;
            public AVAudioServiceType audio_service_type;
            public AVSampleFormat request_sample_fmt;
            public IntPtr get_buffer2;
            public int refcounted_frames;
            public float qcompress;
            public float qblur;
            public int qmin;
            public int qmax;
            public int max_qdiff;
            public float rc_qsquish;
            public float rc_qmod_amp;
            public int rc_qmod_freq;
            public int rc_buffer_size;
            public int rc_override_count;
            public RcOverride* rc_override;
            public sbyte* rc_eq;
            public long rc_max_rate;
            public long rc_min_rate;
            public float rc_buffer_aggressivity;
            public float rc_initial_cplx;
            public float rc_max_available_vbv_use;
            public float rc_min_vbv_overflow_use;
            public int rc_initial_buffer_occupancy;
            public int coder_type;
            public int context_model;
            public int lmin;
            public int lmax;
            public int frame_skip_threshold;
            public int frame_skip_factor;
            public int frame_skip_exp;
            public int frame_skip_cmp;
            public int trellis;
            public int min_prediction_order;
            public int max_prediction_order;
            public long timecode_frame_start;
            public IntPtr rtp_callback;
            public int rtp_payload_size;
            public int mv_bits;
            public int header_bits;
            public int i_tex_bits;
            public int p_tex_bits;
            public int i_count;
            public int p_count;
            public int skip_count;
            public int misc_bits;
            public int frame_bits;
            public sbyte* stats_out;
            public sbyte* stats_in;
            public int workaround_bugs;
            public int strict_std_compliance;
            public int error_concealment;
            public int debug;
            public int debug_mv;
            public int err_recognition;
            public long reordered_opaque;
            public IntPtr hwaccel;
            public void* hwaccel_context;
            public fixed ulong error[8];
            public int dct_algo;
            public int idct_algo;
            public int bits_per_coded_sample;
            public int bits_per_raw_sample;
            public int lowres;
            public AVFrame* coded_frame;
            public int thread_count;
            public int thread_type;
            public int active_thread_type;
            public int thread_safe_callbacks;
            public IntPtr execute;
            public IntPtr execute2;
            public int nsse_weight;
            public int profile;
            public int level;
            public int skip_loop_filter; //enum
            public int skip_idct;  //enum
            public int skip_frame; //enum
            public sbyte* subtitle_header;
            public int subtitle_header_size;
            public int error_rate;
            public ulong vbv_delay;
            public int side_data_only_packets;
            public int initial_padding;
            public AVRational framerate;
            public int sw_pix_fmt; //enum
            public AVRational pkt_timebase;
            public AVCodecDescriptor* codec_descriptor;
            public long pts_correction_num_faulty_pts;
            public long pts_correction_num_faulty_dts;
            public long pts_correction_last_pts;
            public long pts_correction_last_dts;
            public sbyte* sub_charenc;
            public int sub_charenc_mode;
            public int skip_alpha;
            public int seek_preroll;
            public ushort* chroma_intra_matrix;
            public sbyte* dump_separator;
            public sbyte* codec_whitelist;
            public uint properties;
            public IntPtr coded_side_data;
            public int nb_coded_side_data;
        }

        public unsafe partial struct AVCodecDescriptor
        {
            public AVCodecID id;
            public AVMediaType type;
            public sbyte* name;
            public sbyte* long_name;
            public int props;
            public sbyte** mime_types;
            public AVProfile* profiles;
        }

        public unsafe partial struct AVProfile
        {
            public int profile;
            public sbyte* name;
        }

        public enum AVAudioServiceType : int
        {
            AV_AUDIO_SERVICE_TYPE_MAIN = 0,
            AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
            AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
            AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
            AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
            AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
            AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
            AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
            AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
            AV_AUDIO_SERVICE_TYPE_NB = 9,
        }

        public unsafe partial struct AVFrame
        {
            public byte* data0; public byte* data1; public byte* data2; public byte* data3; public byte* data4; public byte* data5; public byte* data6; public byte* data7;
            public fixed int linesize[8];
            public byte** extended_data;
            public int width;
            public int height;
            public int nb_samples;
            public AVSampleFormat format;
            public int key_frame;
            public int pict_type; //enum
            public AVRational sample_aspect_ratio;
            public long pts;
            public long pkt_pts;
            public long pkt_dts;
            public int coded_picture_number;
            public int display_picture_number;
            public int quality;
            public void* opaque;
            public fixed ulong error[8];
            public int repeat_pict;
            public int interlaced_frame;
            public int top_field_first;
            public int palette_has_changed;
            public long reordered_opaque;
            public int sample_rate;
            public ulong channel_layout;
            public AVBufferRef* buf0; 
            public AVBufferRef* buf1; 
            public AVBufferRef* buf2; 
            public AVBufferRef* buf3; 
            public AVBufferRef* buf4; 
            public AVBufferRef* buf5; 
            public AVBufferRef* buf6; 
            public AVBufferRef* buf7;
            public AVBufferRef** extended_buf;
            public int nb_extended_buf;
            public IntPtr* side_data;
            public int nb_side_data;
            public int flags;
            public int color_range; //enum
            public int color_primaries;//enum
            public int color_trc;//enum
            public int colorspace;//enum
            public int chroma_location;//enum

            //??? insert
            //public AVBufferRef* hw_frames_ctx;

            public long best_effort_timestamp;
            public long pkt_pos;
            public long pkt_duration;
            public AVDictionary* metadata;
            public int decode_error_flags;
            public int channels;
            public int pkt_size;
            public sbyte* qscale_table;
            public int qstride;
            public int qscale_type;
            public AVBufferRef* qp_table_buf;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe struct AVBufferRef
        {
            public IntPtr buffer; //AVBuffer
            public byte* data;
            public int size;
        }

        public unsafe partial struct RcOverride
        {
            public int start_frame;
            public int end_frame;
            public int qscale;
            public float quality_factor;
        }

        public unsafe partial struct AVIndexEntry
        {
            public long pos;
            public long timestamp;
            public int flags;
            public int size;
            public int min_distance;
        }

        public unsafe partial struct AVProbeData
        {
            public sbyte* filename;
            public sbyte* buf;
            public int buf_size;
            public sbyte* mime_type;
        }

        public unsafe partial struct AVFrac
        {
            public long val;
            public long num;
            public long den;
        }

        public unsafe partial struct AVRational
        {
            public int num;
            public int den;
        }

        public unsafe partial struct info
        {
            public long last_dts;
            public long duration_gcd;
            public int duration_count;
            public long rfps_duration_sum;
            public IntPtr duration_error;
            public long codec_info_duration;
            public long codec_info_duration_fields;
            public int found_decoder;
            public long last_duration;
            public long fps_first_dts;
            public int fps_first_dts_idx;
            public long fps_last_dts;
            public int fps_last_dts_idx;
        }

        public enum AVStreamParseType : int
        {
            AVSTREAM_PARSE_NONE = 0,
            AVSTREAM_PARSE_FULL = 1,
            AVSTREAM_PARSE_HEADERS = 2,
            AVSTREAM_PARSE_TIMESTAMPS = 3,
            AVSTREAM_PARSE_FULL_ONCE = 4,
            AVSTREAM_PARSE_FULL_RAW = 1463898624,
        }

        public unsafe partial struct AVPacketList
        {
            public AVPacket pkt;
            public AVPacketList* next;
        }

        public unsafe partial struct AVIOContext
        {
            public IntPtr av_class;
            public sbyte* buffer;
            public int buffer_size;
            public sbyte* buf_ptr;
            public sbyte* buf_end;
            public void* opaque;
            public IntPtr read_packet;
            public IntPtr write_packet;
            public IntPtr seek;
            public long pos;
            public int must_flush;
            public int eof_reached;
            public int write_flag;
            public int max_packet_size;
            public int checksum;
            public sbyte* checksum_ptr;
            public IntPtr update_checksum;
            public int error;
            public IntPtr read_pause;
            public IntPtr read_seek;
            public int seekable;
            public long maxsize;
            public int direct;
            public long bytes_read;
            public int seek_count;
            public int writeout_count;
            public int orig_buffer_size;
            public int short_seek_threshold;
            public sbyte* protocol_whitelist;
        }

        public enum AVDurationEstimationMethod : int
        {
            AVFMT_DURATION_FROM_PTS = 0,
            AVFMT_DURATION_FROM_STREAM = 1,
            AVFMT_DURATION_FROM_BITRATE = 2,
        }

        public unsafe partial struct AVIOInterruptCB
        {
            public IntPtr callback;
            public void* opaque;
        }

        public unsafe partial struct AVInputFormat
        {
            public sbyte* name;
            public sbyte* long_name;
            public int flags;
            public sbyte* extensions;
            public IntPtr* codec_tag;
            public IntPtr priv_class;
            public sbyte* mime_type;
            public AVInputFormat* next;
            public int raw_codec_id;
            public int priv_data_size;
            public IntPtr read_probe;
            public IntPtr read_header;
            public IntPtr read_packet;
            public IntPtr read_close;
            public IntPtr read_seek;
            public IntPtr read_timestamp;
            public IntPtr read_play;
            public IntPtr read_pause;
            public IntPtr read_seek2;
            public IntPtr get_device_list;
            public IntPtr create_device_capabilities;
            public IntPtr free_device_capabilities;
        }

        public unsafe partial struct AVOutputFormat
        {
            public sbyte* name;
            public sbyte* long_name;
            public sbyte* mime_type;
            public sbyte* extensions;
            public AVCodecID audio_codec;
            public AVCodecID video_codec;
            public AVCodecID subtitle_codec;
            public int flags;
            public IntPtr* codec_tag;
            public IntPtr priv_class;
            public AVOutputFormat* next;
            public int priv_data_size;
            public IntPtr write_header;
            public IntPtr write_packet;
            public IntPtr write_trailer;
            public IntPtr interleave_packet;
            public IntPtr query_codec;
            public IntPtr get_output_timestamp;
            public IntPtr control_message;
            public IntPtr write_uncoded_frame;
            public IntPtr get_device_list;
            public IntPtr create_device_capabilities;
            public IntPtr free_device_capabilities;
            public AVCodecID data_codec;
            public IntPtr init;
            public IntPtr deinit;
            public IntPtr check_bitstream;
        }

        public unsafe partial struct AVDictionary
        {
        }

        public unsafe partial struct AVCodec
        {
            public sbyte* name;
            public sbyte* long_name;
            public AVMediaType type;
            public AVCodecID id;
            public int capabilities;
            public IntPtr supported_framerates;
            public IntPtr pix_fmts;
            public int* supported_samplerates;
            public AVSampleFormat* sample_fmts;
            public ulong* channel_layouts;
            public sbyte max_lowres;
            public IntPtr priv_class;
            public AVProfile* profiles;
            public int priv_data_size;
            public AVCodec* next;
            public IntPtr init_thread_copy;
            public IntPtr update_thread_context;
            public IntPtr defaults;
            public IntPtr init_static_data;
            public IntPtr init;
            public IntPtr encode_sub;
            public IntPtr encode2;
            public IntPtr decode;
            public IntPtr close;
            public IntPtr flush;
            public int caps_internal;
        }

        public enum AVSampleFormat
        {
            AV_SAMPLE_FMT_NONE = -0x1, // (-1)
            AV_SAMPLE_FMT_U8,
            AV_SAMPLE_FMT_S16,
            AV_SAMPLE_FMT_S32,
            AV_SAMPLE_FMT_FLT,
            AV_SAMPLE_FMT_DBL,
            AV_SAMPLE_FMT_U8P,
            AV_SAMPLE_FMT_S16P,
            AV_SAMPLE_FMT_S32P,
            AV_SAMPLE_FMT_FLTP,
            AV_SAMPLE_FMT_DBLP,
            AV_SAMPLE_FMT_NB,
        }

        public enum AVMediaType
        {
            AVMEDIA_TYPE_UNKNOWN = -0x1, // (-1)
            AVMEDIA_TYPE_VIDEO,
            AVMEDIA_TYPE_AUDIO,
            AVMEDIA_TYPE_DATA,
            AVMEDIA_TYPE_SUBTITLE,
            AVMEDIA_TYPE_ATTACHMENT,
            AVMEDIA_TYPE_NB,
        }

        
    }
}
